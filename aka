#!/usr/bin/env ruby
require 'rubygems'
require 'net/scp'
require 'colorize'
require "safe_yaml/load"
require 'highline/import'
require 'commander/import'

default_command :version #note that this is calling command :version
# always_trace
program :help_formatter, :compact
program :author, 'ytbryan'
program :contact, 'Bryan Lim <ytbryan@gmail.com>'
program :version, '0.3.42'
program :last_update, '13 Jan 2015'
program :description, 'add, remove, edit, manage and grow your aliases from terminal.'
#paths
program :path_to_aka, "#{Dir.home}/.aka"
program :path_to_location, "#{Dir.home}/.aka/.location"
program :path_to_global, "#{Dir.home}/.aka/.global"
program :path_to_groups, "#{Dir.home}/.aka/groups"
program :path_to_remote, "#{Dir.home}/.aka/.remote"
program :path_to_history, "#{Dir.home}/.aka/.history"
program :path_to_settings, "#{Dir.home}/.aka/.settings"
program :path_to_dot_file_history, "#{Dir.home}/.bash_history"

###########################
### CORE
###########################

command :increase do |c|
  c.syntax = 'aka last [options]'
  c.action do |args, options|
    increase_history_limit()
  end
end

command :last do |c|
  c.syntax = 'aka last [options]'
  c.summary = 'show the last few aliases'
  c.action do |args, options|
    if args.first
      showlast(args.first.to_i) if args.first.is_i?
    else
      showlast(10)
    end
  end
end

command :reload do |c|
  c.syntax = 'aka reload'
  c.summary = 'reload dot file'
  c.action do |args, options|
    reload_bash_file()
  end
end

command :add do |c|
  c.syntax = 'aka add [options]'
  c.summary = 'add an alias'
  c.action do |args, options|
    result = add(args.first) if args.first
    reload_bash_file() if result == true
  end
end

command :show do |c|
  c.syntax = 'aka show [options]'
  c.summary = 'show an alias'
  c.action do |args, options|
    show_alias(args.first) if args.first
  end
end

command :history do |c|
  c.syntax = 'aka history [options]'
  c.summary = 'show history'
  c.action do |args, options|
    if args.first
      showHistory(args.first.to_i) if args.first.is_i?
    else
      showHistory(10)
    end
  end
end


# command :find do |c|
#   c.syntax = 'aka find [options]'
#   c.summary = 'find an alias'
#   c.action do |args, options|
#     find(args.first) if args.first
#   end
# end

command :remove do |c|
  c.syntax = 'aka remove [options]'
  c.summary = 'remove an alias'
  c.action do |args, options|
    remove(args.first) if args.first
    reload_bash_file()
  end
end
alias_command :'rm', :remove

command :edit do |c|
  c.syntax = 'aka edit [options]'
  c.summary = 'edit the alias'
  c.action do |args, options|
    truth, _alias = show_alias(args.first)
    if truth == true
      input = ask "Enter a new command for alias '#{args.first}'?\n"
      answer = ask "#{input} confirm? (y/N)"
      if answer == 'y'
        remove(_alias) #remove that alias
        edit(input, _alias) #edit that alias
        reload_bash_file()
      end
    else
      puts "alias '#{args.first}' cannot be found".red
    end
  end
end

command :version do |c|
  c.syntax = 'aka version'
  c.summary = 'show aka version'
  c.action do |args, options|
    version()
    puts ""
  end
end
alias_command :v, :version

command :count do |c|
  c.syntax = 'aka count [options]'
  c.summary = 'count number of alias'
  c.action do |args, options|
    puts "#{count()} aliases from #{return_location_path()}"
    #last three aliases used
    #last three added aliases
    #last three aliases removed
  end
end

###########################
### DEVELOPMENT
###########################

# command :build do |c|
#   c.syntax = 'aka build [options]'
#   c.summary = 'build the VERSION file and run tests'
#   c.action do |args, options|
#     build()
#   end
# end
#
command :copy do |c|
  c.syntax = 'aka copy [options]'
  c.summary = 'copy a local copy of aka to /usr/local/bin'
  c.action do |args, options|
    result = system("sudo cp aka /usr/local/bin")
    puts "Installed aka #{program(:version)} into /usr/local/bin (#{Time.now.strftime("%I:%M%p,%a,%d %b %Y")}).".red if result == true
    puts "" if result == true
  end
end
#
# command :bundle do |c|
#   c.syntax = 'aka bundle [options]'
#   c.summary = 'bundle install dependencies'
#   c.action do |args, options|
#     system("cd ~/.aka")
#     system("bundle install")
#   end
# end

command :uninstall do |c|
  c.syntax = 'aka uninstall [options]'
  c.summary = 'uninstall aka'
  c.action do |args, options|
    input = ask "Confirm that you want to uninstall aka? (y/N)"
    system("sudo rm -rf ~/.aka; sudo rm -rf /usr/local/bin/aka;") if input == "y"
  end
end

command :open do |c|
  c.syntax = 'aka open [options]'
  c.summary = 'simply open the dot file'
  c.action do |args, options|
    system("at  #{return_location_path()}")
  end
end

command :set do |c|
  c.syntax = 'aka set [options]'
  c.summary = 'set the path to a dot file'
  c.action do |args, options|
    # FileUtils.mkdir("#{Dir.home}/.aka") if File.directory?("#{Dir.home}/.aka")
    FileUtils.touch("#{program(:path_to_location)}") if File.exists?("#{program(:path_to_location)}")
    File.write("#{program(:path_to_location)}", args.first) if File.exists?(args.first) #if the file exists
  end
end

command :update do |c|
  c.syntax = 'aka update [options]'
  c.summary = 'update this aka'
  c.action do |args, options|
    update()
  end
end

#aka bb --from path_from_remote --to ytbryan@12312.12.312.3.12.3 --of /path_th_local
# ./aka beamback --from /home/ytbryan/hello --to admin@xxx.xxx.xxx.xxx:port_number_here --of /Users/ytbryan/Desktop/hello
  command :download do |c|
    c.syntax = 'aka download [options]'
    c.summary = 'download a dot file from server'
    c.action do |args, options|
      if options.from and options.to and options.of
        arr = split(options.to.to_s)
        pw = ask "What's the password?"
        result = Net::SCP.download!(arr[1], #remote
        arr.first,#username
        options.from.to_s, #remote_path
        options.of.to_s, #local_path
        :ssh => {:password => pw,
          :port => arr[2]}) if pw
        end
      end
    end
    alias_command :dl, :download

    command :upload do |c|
      c.syntax = 'aka upload [options]'
      c.summary = 'upload a dot file to server'
      c.action do |args, options|
        if options.from and options.to and options.of
          if File.exists?(options.from.to_s)
            arr = split(options.to.to_s)
            result = Net::SCP.upload!(arr[1], #remote
            arr.first, #username
            options.from.to_s, #local_path
            options.of.to_s, #remote_path
            :ssh => {:port => arr[2]})
          else
            puts "Cannot find #{options.from}"
          end
        end
      end
    end

  #############################
  ## Tests
  #############################
  command :test do |c|
    c.syntax = 'aka test [options]'
    c.summary = 'run the tests'
    c.action do |args, options|
      #run the tests
    end
  end

  # command :group do |c|
  #   c.syntax = 'aka group [options]'
  #   c.summary = 'create a new group for aliases'
  #   c.action do |args, options|
  #     #look at groups/ and print out all the files
  #     puts "group is not found at #{Dir.pwd}.\nTo set a group name, type aka group [name]".red
  #   end
  # end
  # alias_command :g, :group

  #############################
  ## Methods
  #############################

  private

  def write_with_newline array
    File.open(get_dot_file_path, 'w') { |file|
      array.each do |line|
        file.write(line + "\n")
      end
    }
  end

  def write str, path
    File.open(path, 'w') { |file| file.write(str) }
  end

  def append str, path
    File.open(path, 'a') { |file| file.write(str) }
  end

  def append_with_newline str, path
    File.open(path, 'a') { |file| file.write(str + "\n") }
  end

  def reload_bash_file()
    system("kill -SIGUSR1 #{Process.ppid}")
  end

  def split_domain_user fulldomain
    username = fulldomain.split("@").first
    domain = fulldomain.split("@")[1]
    return [username, domain]
  end

  def split fulldomain
    username = fulldomain.split("@").first
    domain = fulldomain.split("@")[1].split(":").first
    port = fulldomain.split("@")[1].split(":")[1]
    return [username, domain, port]
  end

  def makeGroup
    alias_path = ".aka/alias.yml"
    group_path = ".aka/group.yml"
    FileUtils.touch(group_path) if File.exist?(group_path)
    #write yaml file
    File.open(group_path, 'w') do |f|
      f.write("")
    end
    #write to group file
    #backup group
    #make .aka file
  end

  def not_empty_alias input
    array = input.split("=")
    return true if array.count < 2
    return array[1].strip == ""
  end

  def add input
    if input and show_alias(input).first == false and not_empty_alias(input) == false
      array = input.split("=")
      full_command = "\nalias #{array.first}='#{array[1]}'"
      File.open(get_dot_file_path, 'a') { |file| file.write(full_command) }
      puts "Added: #{full_command} to #{get_dot_file_path}"
      return true
    else
      puts "The alias is already present."
      return false
    end
  end

  def get_dot_file_path
    # return "#{Dir.home}/#{program(:location)}"
    return "#{return_location_path()}"
  end

  def show_alias argument
    if content = File.open(get_dot_file_path).read
      content.gsub!(/\r\n?/, "\n")
      content_array = content.split("\n")
      content_array.each_with_index { |line, index|
        value = line.split(" ")
        if value.length > 1 and value.first == "alias"
          answer = value[1].split("=")
          if found?(answer.first, argument.split("=").first, line) == true
            return [true, answer.first]
          end
        end
      }
    else
      puts "#{@pwd} cannot be found.".red
      return [false, nil]
    end
    return [false, nil]
  end

  def show argument
    if content = File.open(get_dot_file_path).read
      content.gsub!(/\r\n?/, "\n")
      content_array = content.split("\n")
      content_array.each_with_index { |line, index|
        value = line.split(" ")
        if value.length > 1 and value.first == "alias"
          answer = value[1].split("=")
          if found?(answer.first, argument, line)
            return true
          end
        end
      }
    else
      puts "#{@pwd} cannot be found.".red
      return false
    end
    puts "No alias is found.".red
    return false
  end

  def remove input
    if content=File.open(get_dot_file_path).read
      content.gsub!(/\r\n?/, "\n")
      content_array= content.split("\n")
      content_array.each_with_index { |line, index|
        value = line.split(" ")
        if value.length > 1 and value.first == "alias"
          answer = value[1].split("=")
          if answer.first == input
            content_array.delete_at(index) and write_with_newline(content_array)
            puts "Removed: #{line} from #{Dir.home}/.bash_profile".red
          end
        end
      }
    else
      puts "#{@pwd} cannot be found.".red
    end
  end

  def find input
    if input == nil
      puts "Press q to cancel. or press ctrl+z to stop".red
      input = ask "Which alias to find: (q to quit)"
      if input == "q"
        puts "Exit." and exit()
      end
    end

    founded = false
    if content=File.open(get_dot_file_path).read
      content.gsub!(/\r\n?/, "\n")
      content_array = content.split("\n")
      content_array.each_with_index { |line, index|
        value = line.split(" ")
        if value.length > 1 and value.first == "alias"
          answer = value[1].split("=")
          if found?(answer.first, input, line) == true
            founded = true
          end
        end
      }
      puts "nothing is found." if founded == false
    end
  end

  def record method, command
    record = method + "," + command + "," + Time.now.to_s
    append(record,".history")
  end

  #moved
  def history
    if content = File.open(bash_history_path).read
      puts ".bash_history is available"
      count=0
      content.gsub!(/\r\n?/, "\n")
      content_array = content.split("\n")
      content_array.each_with_index { |line, index|
        array = line.split(" ")
        if array.first == "alias"
          count += 1
        end
        puts "#{index+1} #{line}"
      }
      puts "There are #{count} histories"
    else
      puts ".bash_history is not available".red
    end
  end

  def version
    puts ""
    puts "aka #{program(:version)} - #{program(:last_update)}"
    puts "#{program(:author)} - #{program(:contact)}"
    puts "https://github.com/ytbryan/aka"
  end

  def footer
    puts ""
    puts "Check out 'aka help' for more information about specific commands"
    puts "For full documentation, see: http://github.com/ytbryan/aka#readme"
    puts ""
  end

  def commands
    puts ""
    puts "Some useful aka commands include: "
    puts ""
    puts "-s, -save        save a copy of your dotfile"
    puts "-h, -help        show a list of options and commands"
    puts "-set             set the path to your dotfile"
    puts "-rm, -remove     remove an alias"
    puts "-v, -version     show version of aka"
    puts "-c, -commands    list all the commands"
    puts "-un, -uninstall  uninstall aka"
    puts "-e, -edit        edit aliases"
  end

  def found? answer, argument, line
    if answer == argument
      puts "Found -> " + line.red
      return true
    else
      return false
    end
  end

  def update
    system("sudo rm -rf /usr/local/bin/aka; curl -o /usr/local/bin/aka https://raw.githubusercontent.com/ytbryan/aka/master/cmd/aka; chmod 755 /usr/local/bin/aka") #download the ruby file into _plugins
  end

  def build
    write(program(:version), './VERSION')
    puts "VERSION #{program(:version)} created at #{Time.now.strftime("%I:%M%p, %A, %d %b %Y")}"
  end

  def edit newcommand, this_alias
    return append("alias " + this_alias + "='" + newcommand + "'", get_dot_file_path )
  end

  def count
    alias_count = 0
    if content=File.open(get_dot_file_path).read
      content.gsub!(/\r\n?/, "\n")
      content_array= content.split("\n")
      content_array.each_with_index { |line, index|
        value = line.split(" ")
        if value.length > 1 and value.first == "alias"
          answer = value[1].split("=")
          alias_count += 1
        end
      }
      return alias_count
    end
  end

  def insert_trap
    input = ask "Make your your dot file auto reload #{return_location_path()}? (y/N)"
    if input == 'y'
      trap = "sigusr1() { source ~/.bash_profile; history -a; echo 'reloaded dot file and history file'; }\ntrap sigusr1 SIGUSR1"
      append(trap, "#{return_location_path()}")
    end
  end

  def write_to_location location, address
    if aka_directory_exists?
      # write("#{Dir.home}/#{program(:location)}","#{Dir.home}/.aka/#{program(:path_to_location)}")
      write(location, address)
    else
      puts ".aka not found.".red
    end
  end

  def read location
    answer = dot_location_exists?(location)
    if answer == true and content = File.open(location).read
      return content
    end
    return ""
  end

  # def readFromHistory
  #   answer = dot_location_exists?("#{program(:path_to_history)}")
  #   if answer == true and content = File.open("#{program(:path_to_history)}").read
  #     return content
  #   end
  #   return ""
  # end

  def readFromLocation
    answer = dot_location_exists?("#{program(:path_to_location)}")
    if answer == true and content = File.open("#{program(:path_to_location)}").read
      # puts "#{program(:path_to_location)} is available."
      # puts "->#{content}"
      return content
    end
    return ""
  end

  #find out if file in .location exist
  def dot_location_exists? address
    return File.exist? address
  end

  #if .aka exist?
  def aka_directory_exists?
    return File.directory?("#{Dir.home}/.aka")
  end

  def return_location_path
    return readFromLocation()
  end

  class String
    def pretty
      return self.gsub("\s\t\r\f", ' ').squeeze(' ')
    end

    def is_i?
      !!(self =~ /\A[-+]?[0-9]+\z/)
    end
  end

  def showlast howmany=10
    if content = File.open(get_dot_file_path).read
      content.gsub!(/\r\n?/, "\n")
      content_array = content.split("\n")
      #why not just call the last five lines? Because i can't be sure that they are aliases
      total_aliases = []
      content_array.each_with_index { |line, index|
        value = line.split(" ")
        if value.length > 1 and value.first == "alias"
          total_aliases.push(line)
        end
      }
      puts ""
      if total_aliases.count > howmany
        total_aliases.last(howmany).each_with_index do |line, index|
          puts "#{total_aliases.count - howmany + index+1}. " + line
        end
      else
        total_aliases.last(howmany).each_with_index do |line, index|
          puts "#{index+1}. " + line
        end

      end
      puts ""
    end
  end

  def showHistory howmany=10
    value = reload_bash_file()
    if content = File.open(get_history_file).read
      content.gsub!(/\r\n?/, "\n")
      content_array = content.split("\n")
      total_aliases = []
      content_array.each_with_index { |line, index|
        value = line.split(" ")
        total_aliases.push(value.first)
      }
      count_aliases(total_aliases, howmany)
    end
  end

  def count_aliases array, howmany
    name_array,count_array = [], []
    #find the unique value
    array.each_with_index { |value, index|
      if name_array.include?(value) == false
        name_array.push(value)
      end
    }

    #count the value
    name_array.each { |unique_value|
      count = 0
      array.each { |value|
        if (unique_value == value)
          count+=1
        end
      }
      count_array.push(count)
    }

    sorted_count_array, sorted_name_array = sort(count_array, name_array)

    # #print out
    if sorted_count_array.count == sorted_name_array.count
      puts ""
      sorted_name_array.first(howmany).each_with_index { |value, index|
        percent = ((sorted_count_array[index]).round(2)/array.size.round(2))*100
        puts "#{index+1}. #{value} = #{percent.round(2)}%"
      }
      puts ""
    else
      puts "something is wrong: count_array.count = #{sorted_count_array.count}\n
            name_array.count = #{sorted_name_array.count}. Please check your .bash_history.".pretty
    end
    puts "There's a total of #{array.size} lines in #{program(:path_to_dot_file_history)}."
  end

  def sort(countarray, namearray) #highest first. decscending.
    temp = 0, temp2 = ""
    countarray.each_with_index { |count, index|
      countarray[0..countarray.size-index].each_with_index { |x, thisindex|  #always one less than total

        if index < countarray.size-1 and thisindex < countarray.size-1
          if countarray[thisindex] < countarray[thisindex+1] #if this count is less than next count
            temp = countarray[thisindex]
            countarray[thisindex] = countarray[thisindex+1]
            countarray[thisindex+1] = temp

            temp2 = namearray[thisindex]
            namearray[thisindex] = namearray[thisindex+1]
            namearray[thisindex+1] = temp2
          end
        end

      }
    }#outer loop
    return countarray, namearray
  end


  def get_history_file
    return "#{program(:path_to_dot_file_history)}"
  end

  def get_latest_history_file
    system("history -a")
  end

  def increase_history_limit
    #append to /etc/profile
    append("export HISTSIZE=10000","/etc/profile")
  end

  def setup
    #add the reload code

    #increase the history limit
  end



  #moved
  # def uninstall
  #   input = ""
  #   while input == ""
  #     input = ask "Remove aka? (y/N)".red
  #     if input == "N"
  #       puts "cancel."
  #     elsif input == "y"
  #       system("sudo rm #{@localbin}/aka")
  #       puts "aka removed from #{@localbin}".red
  #     end
  #   end
  # end

  # def set
  #   puts "TODO: path"
  #   system("touch ~/.aka/path")
  #   if content = File.open(bash_history_path).read
  #   end
  # end

  # def readBash
  #   str = "", count = 0
  #   if profile = File.exist?("#{Dir.home}/.bash_profile")
  #     count+= 1
  #     str = "#{count}. #{Dir.home}/.bash_profile\n"
  #   end
  #
  #   if  zsh = File.exist?("#{Dir.home}/.zshrc")
  #     count+= 1
  #     str = str + "#{count}. #{Dir.home}/.zshrc\n"
  #   end
  #
  #   if bashrc = File.exist?("#{Dir.home}/.bashrc")
  #     count+= 1
  #     str = str + "#{count}. #{Dir.home}/.bashrc\n"
  #   end
  #
  #   if count == 0
  #     puts "No .bash_profile or .zshrc or .bashrc detected. Try to create a dot file first."
  #   elsif count == 1
  #     puts "one only"
  #     set_the_dot_file()
  #   elsif profile and zsh and bashrc
  #     puts "three"
  #     input = ask "which dot file do you want to use? \n#{str}"
  #   else
  #     puts "two"
  #     input = ask "Which dot file do you want to use? \n#{str}"
  #   end
  # end

  # #write to .location
  # def single_dot_file_found_write_to_location #always ensure this is safe
  #   puts "enter here"
  #   if profile = File.exist?("#{Dir.home}/.bash_profile")
  #     write_to_location("#{Dir.home}/.bash_profile","#{program(:path_to_location)}" )
  #   elsif zsh = File.exist?("#{Dir.home}/.zshrc")
  #     write_to_location("#{Dir.home}/.zshrc","#{program(:path_to_location)}" )
  #   elsif bashrc = File.exist?("#{Dir.home}/.bashrc")
  #     write_to_location("#{Dir.home}/.bashrc","#{program(:path_to_location)}" )
  #   end
  # end


  # command :janice do |c|
  #   c.syntax = 'aka update [options]'
  #   c.summary = 'update the old copy of aka to a newer one'
  #   c.action do |args, options|
  #     # puts "#{program(:test)}"
  #     puts args
  #     puts Dir.pwd
  #     # str = args.join("\ ") + "/"
  #     # FileUtils.touch("#{Dir.home}/") if File.exists?("#{Dir.home}/
  #     # FileUtils.mkdir_p str
  #   end
  # end

  # command :eh3 do |c|
  #   c.syntax = 'aka switch [options]'
  #   c.summary = 'switch to zsh'
  #   c.action do |args, options|
  #     puts "there is #{Dir["aliases/*"].length} aliases in aliases folder."
  #     if content = File.open(get_dot_file_path).read
  #       content.gsub!(/\r\n?/, "\n")
  #       content_array = content.split("\n")
  #       content_array.each_with_index { |line, index|
  #         value = line.split(" ")
  #         puts line
  #         # if value.length > 1 and value.first == "alias"
  #         #   answer = value[1].split("=")
  #         #   puts answer.first
  #         # end
  #       }
  #     end
  #   end
  # end

  # command :eh2 do |c|
  #   c.syntax = 'aka switch [options]'
  #   c.summary = 'switch to zsh'
  #   c.action do |args, options|
  #     puts "there is #{Dir["aliases/*"].length} aliases in aliases folder."
  #     if content = File.open(get_dot_file_path).read
  #       content.gsub!(/\r\n?/, "\n")
  #       content_array = content.split("\n")
  #       content_array.each_with_index { |line, index|
  #         value = line.split(" ")
  #         if value.length > 1 and value.first == "alias"
  #           answer = value[1].split("=")
  #           alias_name = answer.first
  #           # puts answer.first
  #           out_file = File.new("aliases/#{answer.first}.yml", "w")
  #         end
  #       }
  #     end
  #     # group = YAML.load_file("group.yml")
  #     # puts group["woodcutter"]
  #     # system("echo $SHELL") >> answer
  #     # puts answer
  #     # puts "hello"
  #   end
  # end

  # command :xxx do |c|
  #   c.syntax = 'aka switch [options]'
  #   c.summary = 'switch to zsh'
  #   c.action do |args, options|
  #     readBash()
  #     # add = YAML.load_file("aliases/add.yml")
  #     # add['add']['comment'] = "something esle"
  #     # add['add'][1] = "group"
  #     # add['add'][2] = "tada"
  #     # File.open('aliases/add.yml', 'w') {|f| f.write add.to_yaml } #Store
  #   end
  # end

  # command :sss do |c|
  #   c.syntax = 'aka switch [options]'
  #   c.summary = 'switch to zsh'
  #   c.action do |args, options|
  #     add = YAML.load_file("aliases/add.yml")
  #     add['add']['comment'] = "something esle"
  #     add['add'][1] = "group"
  #     add['add'][2] = "tada"
  #     File.open('aliases/add.yml', 'w') {|f| f.write add.to_yaml } #Store
  #   end
  # end

  # command :read do |c|
  #   c.syntax = 'aka switch [options]'
  #   c.summary = 'switch to zsh'
  #   c.action do |args, options|
  #     add = YAML.load_file("aliases/add.yml")
  #     add['add']['comment'] = "something esle"
  #     add['add'][1] = "group"
  #     add['add'][2] = "tada"
  #     File.open('aliases/add.yml', 'w') {|f| f.write add.to_yaml } #Store
  #   end
  # end

  # command :start do |c|
  #   c.syntax = 'aka switch [options]'
  #   c.summary = 'switch to zsh'
  #   c.action do |args, options|
  #     question = "Which bash file are you using?
  #                 1. .zsh
  #                 2. .bash_profile
  #                 3. .bashrc".pretty
  #     input = ask question
  #   end
  # end

  # command :switch do |c|
  #   c.syntax = 'aka switch [options]'
  #   c.summary = 'switch to zsh'
  #   c.action do |args, options|
  #     write_to_location("hello")
  #     # readFromLocation()
  #   end
  # end

  # command :eh do |c|
  #   c.syntax = 'aka switch [options]'
  #   c.summary = 'switch to zsh'
  #   c.action do |args, options|
  #     puts "there is #{Dir["aliases/*"].length} aliases in aliases folder."
  #     if content = File.open(get_dot_file_path).read
  #       content.gsub!(/\r\n?/, "\n")
  #       content_array = content.split("\n")
  #       content_array.each_with_index { |line, index|
  #         value = line.split(" ")
  #         if value.length > 1 and value.first == "alias"
  #           answer = value[1].split("=")
  #           alias_name = answer.first
  #           out_file = File.new("aliases/#{answer.first}.yml", "w")
  #         end
  #       }
  #     end
  #     # group = YAML.load_file("group.yml")
  #     # puts group["woodcutter"]
  #     # system("echo $SHELL") >> answer
  #     # puts answer
  #     # puts "hello"
  #   end
  # end
  #
  # command :read do |c|
  #   c.syntax = 'aka switch [options]'
  #   c.summary = 'switch to zsh'
  #   c.action do |args, options|
  #     value =  readFromLocation()
  #     answer = dot_location_exists(value)
  #     if value != "" and answer == true
  #       puts value
  #     else
  #       if value != ""
  #         puts "#{value} is found in .location but the actual file is missing. Recreate it first. Or change it using aka set [option]\n Read aka -h for help".red if value != ""
  #       else
  #         puts "Try to set the location of dot file. \naka set .bash_profile #.bashrc #.zshrc".red
  #       end
  #     end
  #   end
  # end

  #############################
  ## Experimental
  #############################

  # command :undo do |c|
  #   c.syntax = 'aka undo [options]'
  #   c.summary = 'undo a removal of alias'
  #   c.action do |args, options|
  #     puts "this undo"
  #   end
  # end

  # command :scan do |c|
  #   c.syntax = 'aka scan [options]'
  #   c.summary = ''
  #   c.action do |args, options|
  #     scan()
  #   end
  # end

  # command :global do |c|
  #   c.syntax = 'aka global [options]'
  #   c.summary = 'set the global aliases'
  #   c.action do |args, options|
  #     # write("hello", "#{program(:path_to_global)}")
  #     value = read("#{program(:path_to_global)}")
  #     if value == ""
  #       puts "No global aliases found. To set the alias group -> aka global [name]".red
  #     else
  #       puts value
  #     end
  #   end
  # end
  #
  # command :size do |c|
  #   c.syntax = 'aka size [options]'
  #   c.summary = 'set the global aliases'
  #   c.action do |args, options|
  #     value =  read("#{program(:path_to_global)}")
  #     array = value.split("\n")
  #     array.each_with_index do |file, index|
  #       puts "file->#{file}"
  #     end
  #   end
  # end
  #
  # command :append do |c|
  #   c.syntax = 'aka global [options]'
  #   c.summary = 'set the global aliases'
  #   c.action do |args, options|
  #     append_with_newline(args.first, "#{program(:path_to_global)}")
  #   end
  # end
  #
  # command :local do |c|
  #   c.syntax = 'aka local [options]'
  #   c.summary = 'set the local group'
  #   c.action do |args, options|
  #     # write("hello", ".group")
  #     value = read(".group")
  #     if value == ""
  #       puts "No local group alias found. To set a local alias group -> aka local [name]".red
  #     else
  #       puts value
  #     end
  #   end
  # end
  #
  # command :showgroups do |c|
  #   c.syntax = 'aka local [options]'
  #   c.action do |args, options|
  #     show_groups()
  #   end
  # end
  #
  # def show_groups
  #   directory = "#{program(:path_to_aka)}/groups/"
  #   filetype = "*.yml"
  #   Dir.glob("#{directory}#{filetype}").each_with_index do |fullname, index|
  #     name =  fullname.slice(directory.size,fullname.size).split(".").first #remove .yml
  #     puts "#{index+1}.#{name}"
  #   end
  #   puts "No alias group is found. To set a global alias group -> aka group [name]".red if Dir.glob("#{directory}#{filetype}").count == 0
  # end
  #
  # command :auto do |c|
  #   c.syntax = 'aka auto [options]'
  #   c.summary = 'auto reload the dot file'
  #   c.action do |args, options|
  #     insert_trap()
  #   end
  # end
