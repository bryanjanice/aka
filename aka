#!/usr/bin/env ruby
require 'rubygems'
require 'commander/import'
require 'highline/import'
require 'net/scp'
require 'colorize'

default_command :version

# always_trace!
program :author, 'ytbryan'
program :contact, 'Bryan Lim <ytbryan@gmail.com>'
program :version, '0.2.23'
program :last_update, '31 Dec 2014' #not going to update
program :description, 'aliases\' best friend'

command :add do |c|
  c.syntax = 'aka add [options]'
  c.summary = 'add an alias'
  c.action do |args, options|
    add(args.first) if args.first
  end
end
alias_command :a, :add

command :show do |c|
  c.syntax = 'aka show [options]'
  c.summary = 'show an alias'
  c.action do |args, options|
    # puts args.first
    show(args.first) if args.first
  end
end
alias_command :s, :show

command :find do |c|
  c.syntax = 'aka find [options]'
  c.summary = 'find an alias'
  c.action do |args, options|
    # puts args.first
    find(args.first) if args.first
  end
end
alias_command :f, :find

command :remove do |c|
  c.syntax = 'aka remove [options]'
  c.summary = 'remove an alias'
  c.action do |args, options|
    remove(args.first) if args.first
  end
end

command :rm do |c|
  c.syntax = 'aka remove [options]'
  c.summary = 'remove an alias'
  c.action do |args, options|
    remove(args.first) if args.first
  end
end

command :undo do |c|
  c.syntax = 'aka undo [options]'
  c.summary = 'undo a removal of alias'
  c.action do |args, options|
    puts "this undo"
  end
end

command :edit do |c|
  c.syntax = 'aka edit [options]'
  c.action do |args, options|
    #search the alias
    if show_alias(args.first)
      input = ask "Enter a new command for alias '#{args.first}'?\n"
      puts "#{input} confirm?"
    else
      puts "alias '#{args.first}' cannot be found".red
    end
    #if present, pop the question

    #if ok, change the alias
  end
end

# command :remote do |c|
#   c.syntax = 'aka remote [options]'
#   c.summary = ''
#   c.description = ''
#   c.example 'description', 'command example'
#   c.option '--ip String', String , 'Some switch that does something'
#   c.option '--username String', String , 'Some switch that does something'
#   c.option '--local String', String , 'Some switch that does something'
#   c.option '--remote String', String , 'Some switch that does something'
#   c.option '--pw String', String , 'Some switch that does something'
#   c.option '--port Integer', Integer , 'Some switch that does something'
#
#   c.action do |args, options|
#
#     Net::SCP.upload!(options.ip.to_s,
#                     options.username.to_s,
#                     options.local.to_s,
#                     options.remote.to_s,
#                     :ssh => {
#                        :port => 1229
#                    })
#   end
# end

command :group do |c|
  c.syntax = 'aka group [options]'
  c.summary = 'create a new group for aliases'
  c.action do |args, options|

  end
end
alias_command :g, :group

command :command do |c|
  c.syntax = 'aka commands [options]'
  c.summary = 'show the list of commands'
  c.action do |args, options|
    commands()
  end
end

command :cmd do |c|
  c.syntax = 'aka commands [options]'
  c.summary = 'show the list of commands'
  c.action do |args, options|
    commands()
  end
end

command :version do |c|
  c.syntax = 'aka version'
  c.summary = 'show the version of this aka'
  c.action do |args, options|
    version()
    puts ""
  end
end
alias_command :v, :version

command :update do |c|
  c.syntax = 'aka update [options]'
  c.summary = 'update the old copy of aka to a newer one'
  c.action do |args, options|
    # puts "shows the version number"
    # github_version = 1.1.1
    # #get the last value and compare
    #
    # #if it is ask for update
    # answer = ask "Do you want to update to #{github_version} (y/N)?"
    update()
    #check the github for newer copy.
    #if this is newer
    #update
    #else
    #print out a message
  end
end

alias_command :u, :update


###########################
### DEVELOPMENT
###########################

command :build do |c|
  c.syntax = 'aka build [options]'
  c.action do |args, options|
    #build by printing the version number

    #test the code

    #commit and save

  end
end
alias_command :b, :build

command :copy do |c|
  c.syntax = 'aka copy [options]'
  c.summary = 'copy a local copy of aka to /usr/local/bin'
  c.action do |args, options|
    system("sudo cp aka /usr/local/bin")
    puts "Open a new tab for the changes to take effect.".red
    puts ""
  end
end
alias_command :c, :copy

command :install do |c|
  c.syntax = 'aka install [options]'
  c.summary = 'bundle install the gemfile in .aka'
  c.action do |args, options|
    system("cd ~/.aka")
    system("bundle install")
  end
end
alias_command :i, :install

# command :uninstall do |c|
#   c.syntax = 'aka uninstall [options]'
#   c.summary = ''
#   c.description = ''
#   c.example 'description', 'command example'
#   c.option '--some-switch', 'Some switch that does something'
#   c.action do |args, options|
#     # Do something or c.when_called Aka::Commands::Uninstall
#   end
# end

command :open do |c|
  c.syntax = 'aka open [options]'
  c.summary = 'simply open the bashfile'
  c.action do |args, options|
    write(args.first) if args.first
  end
end


command :set do |c|
  c.syntax = 'aka set [options]'
  c.summary = 'set the path of your bash config file'
  c.action do |args, options|
    # FileUtils.mkdir("#{Dir.home}/.aka") if File.directory?("#{Dir.home}/.aka")
    FileUtils.touch("#{Dir.home}/.aka/location") if File.exists?("#{Dir.home}/.aka/location")
    File.write("#{Dir.home}/.aka/location", args.first) if File.exists?(args.first) #if the file exists
  end
end

command :scan do |c|
  c.syntax = 'aka scan [options]'
  c.summary = ''
  c.action do |args, options|
    scan()
  end
end


#aka bb --from path_from_remote --to ytbryan@12312.12.312.3.12.3 --of /path_th_local
# ./aka beamback --from /home/ytbryan/hello --to admin@xxx.xxx.xxx.xxx:port_number_here --of /Users/ytbryan/Desktop/hello
command :dl do |c|
  c.syntax = 'aka beam [options]'
  c.option '--from STRING', String, 'Some switch that does something'
  c.option '--to STRING', String, 'Some switch that does something'
  c.option '--of STRING', String, 'Some switch that does something'
  c.action do |args, options|

    if options.from and options.to and options.of
      arr = split(options.to.to_s)
      pw = ask "What's the password?"
      result = Net::SCP.download!(arr[1], #remote
      arr.first,#username
      options.from.to_s, #remote_path
      options.of.to_s, #local_path
      :ssh => {:password => pw,
        :port => arr[2]}) if pw
      end
    end
  end

  command :beam do |c|
    c.syntax = 'aka beam [options]'
    c.option '--from STRING', String, 'Some switch that does something'
    c.option '--to STRING', String, 'Some switch that does something'
    c.option '--of STRING', String, 'Some switch that does something'
    c.action do |args, options|

      if options.from and options.to and options.of
        if File.exists?(options.from.to_s)
          arr = split(options.to.to_s)
          result = Net::SCP.upload!(arr[1], #remote
          arr.first, #username
          options.from.to_s, #local_path
          options.of.to_s, #remote_path
          :ssh => {:port => arr[2]})
        else
          puts "Cannot find #{options.from}"
        end
      end

    end
  end
  alias_command :b, :beam

  private

  def reload()
    system("source ~/.bash_profile")
  end

  def split_domain_user fulldomain
    username = fulldomain.split("@").first
    domain = fulldomain.split("@")[1]
    return [username, domain]
  end

  def split fulldomain
    username = fulldomain.split("@").first
    domain = fulldomain.split("@")[1].split(":").first
    port = fulldomain.split("@")[1].split(":")[1]
    return [username, domain, port]
  end

  def makeGroup
    alias_path = ".aka/alias.yml"
    group_path = ".aka/group.yml"
    FileUtils.touch(group_path) if File.exist?(group_path)
    #write yaml file
    File.open(group_path, 'w') do |f|
      f.write("")
    end
    #write to group file
    #backup group
    #make .aka file
  end

  def not_empty_alias input
    array = input.split("=")
    return true if array.count < 2
    return array[1].strip == ""
  end

  def addf command
    #add a command
    #function xxxx { cmdddddddd; };
  end

  def add input
    if input and show_alias(input) == false and not_empty_alias(input) == false
      array = input.split("=")
      full_command = "\nalias #{array.first}='#{array[1]}'"
      File.open(get_bash_profile_path, 'a') { |file| file.write(full_command) }
      puts "Added: #{full_command} to #{get_bash_profile_path}" and reload()
    else
      puts "The alias is already present."
    end
  end

  def write_new_file array
    File.open(get_bash_profile_path, 'w') { |file|
      array.each do |line|
        file.write(line + "\n")
      end
    }
  end

  def write str, path
    File.open(path, 'w') { |file|
      file.write(str)
    }
  end

  def get_bash_profile_path
    return "#{Dir.home}/.bash_profile"
  end

  def show_alias argument
    if content = File.open(get_bash_profile_path).read
      content.gsub!(/\r\n?/, "\n")
      content_array = content.split("\n")
      content_array.each_with_index { |line, index|
        value = line.split(" ")
        if value.length > 1 and value.first == "alias"
          answer = value[1].split("=")
          if found?(answer.first, argument.split("=").first, line) == true
            return true
          end
        end
      }
    else
      puts "#{@pwd} cannot be found.".red
      return false
    end
    return false
  end

  def show argument
    if content = File.open(get_bash_profile_path).read
      content.gsub!(/\r\n?/, "\n")
      content_array = content.split("\n")
      content_array.each_with_index { |line, index|
        value = line.split(" ")
        if value.length > 1 and value.first == "alias"
          answer = value[1].split("=")
          if found?(answer.first, argument, line)
            return true
          end
        end
      }
    else
      puts "#{@pwd} cannot be found.".red
      return false
    end
    puts "No alias is found.".red
    return false
  end


  def remove input
    if content=File.open(get_bash_profile_path).read
      content.gsub!(/\r\n?/, "\n")
      content_array= content.split("\n")
      content_array.each_with_index { |line, index|
        value = line.split(" ")
        if value.length > 1 and value.first == "alias"
          answer = value[1].split("=")
          if answer.first == input
            content_array.delete_at(index) and write_new_file(content_array)
            puts "Removed: #{line} from #{Dir.home}/.bash_profile".red
          end
        end
      }
    else
      puts "#{@pwd} cannot be found.".red
    end
  end

  def find input
    if input == nil
      puts "Press q to cancel. or press ctrl+z to stop".red
      input = ask "Which alias to find: (q to quit)"
      if input == "q"
        puts "Exit." and exit()
      end
    end

    founded = false
    if content=File.open(get_bash_profile_path).read
      content.gsub!(/\r\n?/, "\n")
      content_array = content.split("\n")
      content_array.each_with_index { |line, index|
        value = line.split(" ")
        if value.length > 1 and value.first == "alias"
          answer = value[1].split("=")
          if found?(answer.first, input, line) == true
            founded = true
          end
        end
      }

      puts "nothing is found." if founded == false
    end

  end

  #moved
  def history
    if content = File.open(bash_history_path).read
      puts ".bash_history is available"
      count=0
      content.gsub!(/\r\n?/, "\n")
      content_array = content.split("\n")
      content_array.each_with_index { |line, index|
        array = line.split(" ")
        if array.first == "alias"
          count += 1
        end
        puts "#{index+1} #{line}"
      }
      puts "There are #{count} histories"
    else
      puts ".bash_history is not available".red
    end
  end

  #moved
  def uninstall
    input = ""
    while input == ""
      input = ask "Remove aka? (y/N)".red
      if input == "N"
        puts "cancel."
      elsif input == "y"
        system("sudo rm #{@localbin}/aka")
        puts "aka removed from #{@localbin}".red
      end
    end
  end

  def set
    puts "TODO: path"
    system("touch ~/.aka/path")
    if content = File.open(bash_history_path).read
    end
  end

  def version
    puts ""
    puts "aka #{program(:version)} - #{program(:last_update)}"
    puts "#{program(:author)} - #{program(:contact)}"
    puts "https://github.com/ytbryan/aka"
  end

  def footer
    puts ""
    puts "Check out 'aka -help' for more information about specific commands"
    puts "For full documentation, see: http://github.com/ytbryan/aka#readme"
    puts ""
  end

  def commands
    puts ""
    puts "Some useful aka commands include: "
    puts ""
    puts "-s, -save        save a copy of your dotfile"
    puts "-h, -help        show a list of options and commands"
    puts "-set             set the path to your dotfile"
    puts "-rm, -remove     remove an alias"
    puts "-v, -version     show version of aka"
    puts "-c, -commands    list all the commands"
    puts "-un, -uninstall  uninstall aka"
    puts "-e, -edit        edit aliases"
    # puts "-ex, -example    show some example"
  end

  def found? answer, argument, line
    if answer == argument
      puts "Found -> " + line.red
      return true
    else
      return false
    end
  end

  def update
    system("sudo rm -rf /usr/local/bin/aka; curl -o /usr/local/bin/aka https://raw.githubusercontent.com/ytbryan/aka/master/cmd/aka; chmod 755 /usr/local/bin/aka") #download the ruby file into _plugins
  end
